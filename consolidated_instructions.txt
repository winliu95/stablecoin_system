use anchor_lang::prelude::*;
use anchor_spl::token::{self, Mint, Token, TokenAccount, Burn};
use crate::state::*;

#[derive(Accounts)]
pub struct BurnUsdt<'info> {
    #[account(mut)]
    pub owner: Signer<'info>,

    #[account(
        mut,
        seeds = [b"position", owner.key().as_ref(), collateral_mint.key().as_ref()],
        bump = position.bump,
        has_one = collateral_mint,
        has_one = owner,
    )]
    pub position: Account<'info, Position>,

    #[account(
        mut,
        seeds = [b"mint"],
        bump,
    )]
    pub usdt_mint: Account<'info, Mint>,

    #[account(
        mut,
        associated_token::mint = usdt_mint,
        associated_token::authority = owner,
    )]
    pub user_usdt_account: Account<'info, TokenAccount>,
    
    pub collateral_mint: Account<'info, Mint>,

    pub token_program: Program<'info, Token>,

    #[account(
        seeds = [b"global_state"],
        bump = global_state.bump,
    )]
    pub global_state: Account<'info, GlobalState>,
}

pub fn handler(ctx: Context<BurnUsdt>, amount: u64) -> Result<()> {
    // 0. Governance Checks
    let global_state = &ctx.accounts.global_state;
    if global_state.paused {
        return err!(CustomErrorCode::Paused);
    }
    
    let position = &mut ctx.accounts.position;
    if position.is_frozen {
        return err!(CustomErrorCode::Frozen);
    }

    // 1. Burn Tokens
    let cpi_accounts = Burn {
        mint: ctx.accounts.usdt_mint.to_account_info(),
        from: ctx.accounts.user_usdt_account.to_account_info(),
        authority: ctx.accounts.owner.to_account_info(),
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    token::burn(cpi_ctx, amount)?;

    // 2. Update Position
    let position = &mut ctx.accounts.position;
    
    // Ensure we don't underflow (though burn ensures user has tokens, checking debt is good practice)
    // In some designs, user might hold stablecoin from elsewhere, but here we just reduce debt up to amount burned.
    // However, usually you can't reduce debt below 0.
    
    if amount > position.debt_amount {
        position.debt_amount = 0;
        // The excess burn is a donation to the protocol or just lost.
    } else {
        position.debt_amount = position.debt_amount.checked_sub(amount).unwrap();
    }
    
    position.last_updated = Clock::get()?.unix_timestamp;

    msg!("Burned {} USDT. New Debt: {}", amount, position.debt_amount);
    Ok(())
}
use anchor_lang::prelude::*;
use crate::state::*;

#[derive(Accounts)]
#[instruction(collateral_mint: Pubkey)]
pub struct ConfigureCollateral<'info> {
    #[account(
        init_if_needed,
        payer = admin,
        seeds = [b"collateral", collateral_mint.key().as_ref()],
        bump,
        space = CollateralConfig::LEN
    )]
    pub collateral_config: Account<'info, CollateralConfig>,

    #[account(
        has_one = admin,
        seeds = [b"global_state"],
        bump = global_state.bump
    )]
    pub global_state: Account<'info, GlobalState>,

    #[account(mut)]
    pub admin: Signer<'info>,

    pub system_program: Program<'info, System>,
}

pub fn handler(
    ctx: Context<ConfigureCollateral>,
    collateral_mint: Pubkey,
    oracle: Pubkey,
    mcr: u64,
    ltr: u64,
    liquidation_penalty: u64,
) -> Result<()> {
    let config = &mut ctx.accounts.collateral_config;
    config.collateral_mint = collateral_mint;
    config.oracle = oracle;
    config.mcr = mcr;
    config.ltr = ltr;
    config.liquidation_penalty = liquidation_penalty;
    config.bump = ctx.bumps.collateral_config;

    msg!("Collateral Configured. Mint: {}, MCR: {}", collateral_mint, mcr);
    Ok(())
}
use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Transfer};
use crate::state::*;

#[derive(Accounts)]
pub struct DepositCollateral<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        mut,
        seeds = [b"collateral", collateral_mint.key().as_ref()],
        bump = collateral_config.bump,
    )]
    pub collateral_config: Account<'info, CollateralConfig>,

    pub collateral_mint: Account<'info, token::Mint>,

    #[account(
        mut,
        associated_token::mint = collateral_mint,
        associated_token::authority = user,
    )]
    pub user_token_account: Account<'info, TokenAccount>,

    #[account(
        init_if_needed,
        payer = user,
        seeds = [b"vault", collateral_mint.key().as_ref()],
        bump,
        token::mint = collateral_mint,
        token::authority = vault_authority,
    )]
    pub vault_token_account: Account<'info, TokenAccount>,

    /// CHECK: This is the PDA authority for the vault
    #[account(seeds = [b"vault_authority"], bump)]
    pub vault_authority: AccountInfo<'info>,

    #[account(
        init_if_needed,
        payer = user,
        seeds = [b"position", user.key().as_ref(), collateral_mint.key().as_ref()],
        bump,
        space = Position::LEN
    )]
    pub position: Account<'info, Position>,

    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
    
    #[account(
        seeds = [b"global_state"],
        bump = global_state.bump,
    )]
    pub global_state: Account<'info, GlobalState>,
}

pub fn handler(ctx: Context<DepositCollateral>, amount: u64) -> Result<()> {
    // 0. Governance Checks
    let global_state = &ctx.accounts.global_state;
    if global_state.paused {
        return err!(CustomErrorCode::Paused);
    }
    
    let position = &mut ctx.accounts.position;
    if position.is_frozen {
        return err!(CustomErrorCode::Frozen);
    }
    // 1. Transfer tokens from user to vault
    let cpi_accounts = Transfer {
        from: ctx.accounts.user_token_account.to_account_info(),
        to: ctx.accounts.vault_token_account.to_account_info(),
        authority: ctx.accounts.user.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    token::transfer(cpi_ctx, amount)?;

    // 2. Update Position
    // let position = &mut ctx.accounts.position; // Already borrowed mutably above
    if position.owner == Pubkey::default() {
        position.owner = ctx.accounts.user.key();
        position.collateral_mint = ctx.accounts.collateral_mint.key();
        position.bump = ctx.bumps.position;
    }
    
    position.collateral_amount = position.collateral_amount.checked_add(amount).unwrap();
    position.last_updated = Clock::get()?.unix_timestamp;

    msg!("Deposited {} collateral. New Balance: {}", amount, position.collateral_amount);
    Ok(())
}
use anchor_lang::prelude::*;
use crate::state::*;

#[derive(Accounts)]
pub struct TogglePause<'info> {
    #[account(
        mut,
        seeds = [b"global_state"],
        bump = global_state.bump,
        has_one = admin,
    )]
    pub global_state: Account<'info, GlobalState>,
    pub admin: Signer<'info>,
}

#[derive(Accounts)]
pub struct ToggleFreeze<'info> {
    #[account(
        mut,
        seeds = [b"global_state"],
        bump = global_state.bump,
        has_one = admin,
    )]
    pub global_state: Account<'info, GlobalState>,
    
    #[account(
        mut,
        // The position to freeze
    )]
    pub position: Account<'info, Position>,
    
    pub admin: Signer<'info>,
}

pub fn handler_pause(ctx: Context<TogglePause>, paused: bool) -> Result<()> {
    let global_state = &mut ctx.accounts.global_state;
    global_state.paused = paused;
    msg!("System Pause State: {}", paused);
    Ok(())
}

pub fn handler_freeze(ctx: Context<ToggleFreeze>, frozen: bool) -> Result<()> {
    let position = &mut ctx.accounts.position;
    position.is_frozen = frozen;
    msg!("Position Frozen State: {}", frozen);
    Ok(())
}
use anchor_lang::prelude::*;
use anchor_spl::token;
use crate::state::*;

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init, 
        payer = admin, 
        seeds = [b"global_state"],
        bump, 
        space = GlobalState::LEN
    )]
    pub global_state: Account<'info, GlobalState>,

    #[account(
        init,
        payer = admin,
        seeds = [b"mint"],
        bump,
        mint::decimals = 6,
        mint::authority = global_state,
    )]
    pub usdt_mint: Account<'info, token::Mint>,
    
    #[account(mut)]
    pub admin: Signer<'info>,
    
    pub token_program: Program<'info, token::Token>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}

pub fn handler(ctx: Context<Initialize>) -> Result<()> {
    let global_state = &mut ctx.accounts.global_state;
    global_state.admin = ctx.accounts.admin.key();
    global_state.usdt_mint = ctx.accounts.usdt_mint.key();
    global_state.total_supply = 0;
    global_state.paused = false;
    global_state.bump = ctx.bumps.global_state;
    
    msg!("Global State Initialized. Admin: {}, Mint: {}", global_state.admin, global_state.usdt_mint);
    Ok(())
}

use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Transfer, Burn, Mint};
use crate::state::*;
use crate::utils::get_price;

#[derive(Accounts)]
pub struct Liquidate<'info> {
    #[account(mut)]
    pub liquidator: Signer<'info>,

    #[account(
        mut,
        seeds = [b"position", position_owner.key().as_ref(), collateral_mint.key().as_ref()],
        bump = position.bump,
        has_one = collateral_mint,
    )]
    pub position: Account<'info, Position>,

    
    /// CHECK: The owner of the position being liquidated
    #[account()]
    pub position_owner: AccountInfo<'info>,

    #[account(
        seeds = [b"collateral", collateral_mint.key().as_ref()],
        bump = collateral_config.bump,
    )]
    pub collateral_config: Account<'info, CollateralConfig>,

    /// CHECK: Validated against config
    #[account(address = collateral_config.oracle)]
    pub oracle: AccountInfo<'info>,

    #[account(
        mut,
        seeds = [b"mint"],
        bump,
    )]
    pub usdt_mint: Account<'info, Mint>,

    #[account(
        mut,
        associated_token::mint = usdt_mint,
        associated_token::authority = liquidator,
    )]
    pub liquidator_usdt_account: Account<'info, TokenAccount>,

    #[account(
        mut,
        associated_token::mint = collateral_mint,
        associated_token::authority = liquidator,
    )]
    pub liquidator_collateral_account: Account<'info, TokenAccount>,

    #[account(
        mut,
        seeds = [b"vault", collateral_mint.key().as_ref()],
        bump,
        token::mint = collateral_mint,
        token::authority = vault_authority,
    )]
    pub vault_token_account: Account<'info, TokenAccount>,

    /// CHECK: Vault authority PDA
    #[account(seeds = [b"vault_authority"], bump)]
    pub vault_authority: AccountInfo<'info>,

    pub collateral_mint: Account<'info, Mint>,

    pub token_program: Program<'info, Token>,

    #[account(
        seeds = [b"global_state"],
        bump = global_state.bump,
    )]
    pub global_state: Account<'info, GlobalState>,
}

pub fn handler(ctx: Context<Liquidate>, amount_to_repay: u64) -> Result<()> {
    // 0. Governance Checks
    let global_state = &ctx.accounts.global_state;
    if global_state.paused {
        return err!(CustomErrorCode::Paused);
    }

    let position = &mut ctx.accounts.position;
    
    // 1. Check Solvency (Current CR < MCR ?)
    let price = get_price(&ctx.accounts.oracle)?; // e.g. 150*10^6
    
    let collateral_val = (position.collateral_amount as u128)
        .checked_mul(price as u128).unwrap()
        .checked_div(10u128.pow(ctx.accounts.collateral_mint.decimals as u32)).unwrap() as u64;
    
    let mcr_percent = ctx.accounts.collateral_config.mcr;
    let required_collateral_value = (position.debt_amount as u128)
        .checked_mul(mcr_percent as u128).unwrap()
        .checked_div(100).unwrap();
        
    // If Position is SAFE, revert
    if (collateral_val as u128) >= required_collateral_value {
        return err!(CustomErrorCode::PositionSafe);
    }
    
    // 2. Burn Liquidator's USDT
    let repay_amount = if amount_to_repay > position.debt_amount {
        position.debt_amount // Cap at full debt
    } else {
        amount_to_repay
    };

    let cpi_accounts = Burn {
        mint: ctx.accounts.usdt_mint.to_account_info(),
        from: ctx.accounts.liquidator_usdt_account.to_account_info(),
        authority: ctx.accounts.liquidator.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    token::burn(cpi_ctx, repay_amount)?;

    // 3. Calculate Collateral to Seize with Penalty
    // Seize Value = Repay Value * (1 + Penalty)
    // Repay Value in USD (repay_amount is USDT units, assuming 1 USDT ~ 1 USD if maintained)
    // We treat 1 USDT as worth 1 USD for payout calc usually.
    // Penalty is percentage, e.g. 10 (10%).
    
    let penalty = ctx.accounts.collateral_config.liquidation_penalty;
    let total_value_to_seize = (repay_amount as u128)
        .checked_mul(100 + penalty as u128).unwrap()
        .checked_div(100).unwrap();
        
    // Convert Value back to Collateral Units
    // Amount = Value * 10^Decimals / Price
    let collateral_to_seize = total_value_to_seize
        .checked_mul(10u128.pow(ctx.accounts.collateral_mint.decimals as u32)).unwrap()
        .checked_div(price as u128).unwrap() as u64;

    // 4. Update Position
    position.debt_amount = position.debt_amount.checked_sub(repay_amount).unwrap();
    
    // Check if we have enough collateral
    let actual_seize_amount = if collateral_to_seize > position.collateral_amount {
        position.collateral_amount // Take everything if not enough (Bad Debt scenario)
    } else {
        collateral_to_seize
    };
    
    position.collateral_amount = position.collateral_amount.checked_sub(actual_seize_amount).unwrap();
    position.last_updated = Clock::get()?.unix_timestamp;

    // 5. Transfer Collateral
    let seeds = &[b"vault_authority".as_ref(), &[ctx.bumps.vault_authority]];
    let signer = &[&seeds[..]];

    let cpi_accounts_transfer = Transfer {
        from: ctx.accounts.vault_token_account.to_account_info(),
        to: ctx.accounts.liquidator_collateral_account.to_account_info(),
        authority: ctx.accounts.vault_authority.to_account_info(),
    };
    let cpi_ctx_transfer = CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), cpi_accounts_transfer, signer);
    token::transfer(cpi_ctx_transfer, actual_seize_amount)?;

    msg!("Liquidated {} debt. Seized {} collateral.", repay_amount, actual_seize_amount);
    Ok(())
}


use anchor_lang::prelude::*;
use anchor_spl::token::{self, Mint, Token, TokenAccount, MintTo};
use crate::state::*;
use crate::utils::get_price;

#[derive(Accounts)]
pub struct MintUsdt<'info> {
    #[account(mut)]
    pub owner: Signer<'info>,

    #[account(
        mut,
        seeds = [b"position", owner.key().as_ref(), collateral_mint.key().as_ref()],
        bump = position.bump,
        has_one = collateral_mint,
        has_one = owner,
    )]
    pub position: Account<'info, Position>,

    #[account(
        seeds = [b"collateral", collateral_mint.key().as_ref()],
        bump = collateral_config.bump,
    )]
    pub collateral_config: Account<'info, CollateralConfig>,

    /// CHECK: Validated against config
    #[account(
        address = collateral_config.oracle
    )]
    pub oracle: AccountInfo<'info>,

    #[account(
        mut,
        seeds = [b"mint"],
        bump,
    )]
    pub usdt_mint: Account<'info, Mint>,

    #[account(
        init_if_needed,
        payer = owner,
        associated_token::mint = usdt_mint,
        associated_token::authority = owner,
    )]
    pub user_usdt_account: Account<'info, TokenAccount>,
    
    pub collateral_mint: Account<'info, Mint>,
    
    #[account(
        seeds = [b"global_state"],
        bump = global_state.bump,
    )]
    pub global_state: Account<'info, GlobalState>,

    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, anchor_spl::associated_token::AssociatedToken>,
    pub system_program: Program<'info, System>,
}

pub fn handler(ctx: Context<MintUsdt>, amount_to_mint: u64) -> Result<()> {
    // 0. Governance Checks
    let global_state = &ctx.accounts.global_state;
    if global_state.paused {
        return err!(CustomErrorCode::Paused);
    }
    
    let position = &mut ctx.accounts.position;
    if position.is_frozen {
        return err!(CustomErrorCode::Frozen);
    }

    // 1. Get Price
    let price = get_price(&ctx.accounts.oracle)?; // e.g. 150*10^6
    
    // 2. Calculate Collateral Value
    // Collateral Amount (e.g. 9 decimals for SOL) -> convert to unified value
    // Price has 6 decimals? Let's assume price is in USD with 6 decimals.
    // Value = (CollateralAmount * Price) / 10^CollateralDecimals
    // Let's assume standard math here. Note: Overflow checks needed.
    // For simplicity: Value (USD 6 decimals) = Collateral (Native) * Price (USD per Native) / 10^NativeDecimals
    
    let position = &mut ctx.accounts.position;
    let collateral_val = (position.collateral_amount as u128)
        .checked_mul(price as u128).unwrap()
        .checked_div(10u128.pow(ctx.accounts.collateral_mint.decimals as u32)).unwrap() as u64;
        
    // 3. New Debt
    let new_debt = position.debt_amount.checked_add(amount_to_mint).unwrap();
    
    // 4. Check Context Ratio
    // CR = Collateral Value / Debt Value * 100 >= MCR
    // MCR is likely defined as 150 (for 150%).
    
    let mcr_percent = ctx.accounts.collateral_config.mcr; // e.g. 150
    let required_collateral_value = (new_debt as u128)
        .checked_mul(mcr_percent as u128).unwrap()
        .checked_div(100).unwrap();
        
    if (collateral_val as u128) < required_collateral_value {
        return err!(CustomErrorCode::BelowMcr);
    }
    
    // 5. Mint
    let seeds = &[b"global_state".as_ref(), &[ctx.accounts.global_state.bump]];
    let signer = &[&seeds[..]];

    let cpi_accounts = MintTo {
        mint: ctx.accounts.usdt_mint.to_account_info(),
        to: ctx.accounts.user_usdt_account.to_account_info(),
        authority: ctx.accounts.global_state.to_account_info(), // GlobalState is authoirty
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    // Note: The authority is global_state account which is a PDA.
    // Wait, in initialize, I set authority to global_state.
    
    let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);
    token::mint_to(cpi_ctx, amount_to_mint)?;

    // 6. Update Position
    position.debt_amount = new_debt;
    position.last_updated = Clock::get()?.unix_timestamp;
    
    // 7. Update Global Supply
    // Note: Tracking global supply in GlobalState is optional if Mint tracks it.
    
    msg!("Minted {} USDT. New Debt: {}", amount_to_mint, new_debt);
    Ok(())
}


use anchor_lang::prelude::*;
use crate::state::*;

#[derive(Accounts)]
pub struct SetMockPrice<'info> {
    #[account(
        init_if_needed,
        payer = admin,
        space = MockPriceAccount::LEN,
        seeds = [b"mock_oracle"],
        bump
    )]
    pub mock_price_account: Account<'info, MockPriceAccount>,
    
    #[account(mut)]
    pub admin: Signer<'info>,
    
    pub system_program: Program<'info, System>,
}

pub fn handler(ctx: Context<SetMockPrice>, price: u64) -> Result<()> {
    let mock_price_account = &mut ctx.accounts.mock_price_account;
    mock_price_account.price = price;
    msg!("Mock Price updated to: {}", price);
    Ok(())
}
pub mod initialize;
pub mod configure_collateral;
pub mod deposit_collateral;
pub mod mint_usdt;
pub mod burn_usdt;
pub mod withdraw_collateral;
pub mod liquidate;
pub mod governance;
pub mod psm;
pub mod mock_oracle;

pub use initialize::Initialize;
pub use configure_collateral::ConfigureCollateral;
pub use deposit_collateral::DepositCollateral;
pub use mint_usdt::MintUsdt;
pub use burn_usdt::BurnUsdt;
pub use withdraw_collateral::WithdrawCollateral;
pub use liquidate::Liquidate;
pub use governance::{TogglePause, ToggleFreeze};
pub use psm::{ConfigurePsm, SwapUsdcToUsdt, SwapUsdtToUsdc};









use anchor_lang::prelude::*;
use anchor_spl::token::{self, Mint, Token, TokenAccount, Transfer, MintTo, Burn};
use crate::state::*;

#[derive(Accounts)]
pub struct ConfigurePsm<'info> {
    #[account(mut)]
    pub admin: Signer<'info>,

    #[account(
        seeds = [b"global_state"],
        bump = global_state.bump,
        has_one = admin,
    )]
    pub global_state: Account<'info, GlobalState>,

    pub token_mint: Account<'info, Mint>, // e.g. USDC

    #[account(
        init,
        payer = admin,
        seeds = [b"psm", token_mint.key().as_ref()],
        bump,
        space = 8 + 32 + 32 + 8 + 8 + 1
    )]
    pub psm_config: Account<'info, PsmConfig>,

    #[account(
        init,
        payer = admin,
        seeds = [b"psm_vault", token_mint.key().as_ref()],
        bump,
        token::mint = token_mint,
        token::authority = global_state, // GlobalState owns the vault? Or a separate PDA?
    )]
    pub psm_vault: Account<'info, TokenAccount>,
    
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}

#[account]
pub struct PsmConfig {
    pub token_mint: Pubkey,
    pub vault: Pubkey,
    pub total_minted: u64,
    pub fee_basis_points: u64, // e.g. 10 = 0.1%
    pub bump: u8,
}

#[derive(Accounts)]
pub struct SwapUsdcToUsdt<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        mut,
        seeds = [b"psm", token_mint.key().as_ref()],
        bump = psm_config.bump,
    )]
    pub psm_config: Account<'info, PsmConfig>,

    pub token_mint: Account<'info, Mint>,

    #[account(
        mut,
        seeds = [b"psm_vault", token_mint.key().as_ref()],
        bump,
    )]
    pub psm_vault: Account<'info, TokenAccount>,

    #[account(
        mut,
        associated_token::mint = token_mint,
        associated_token::authority = user,
    )]
    pub user_token_account: Account<'info, TokenAccount>,

    #[account(
        mut,
        seeds = [b"mint"],
        bump,
    )]
    pub usdt_mint: Account<'info, Mint>,

    #[account(
        mut,
        associated_token::mint = usdt_mint,
        associated_token::authority = user,
    )]
    pub user_usdt_account: Account<'info, TokenAccount>,
    
    #[account(
        seeds = [b"global_state"],
        bump = global_state.bump,
    )]
    pub global_state: Account<'info, GlobalState>,

    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, anchor_spl::associated_token::AssociatedToken>,
    pub system_program: Program<'info, System>,
}

pub fn handler_configure(ctx: Context<ConfigurePsm>, fee_bps: u64) -> Result<()> {
    let psm_config = &mut ctx.accounts.psm_config;
    psm_config.token_mint = ctx.accounts.token_mint.key();
    psm_config.vault = ctx.accounts.psm_vault.key();
    psm_config.fee_basis_points = fee_bps;
    psm_config.bump = ctx.bumps.psm_config;
    msg!("PSM Configured for {}", ctx.accounts.token_mint.key());
    Ok(())
}

pub fn handler_swap_to_usdt(ctx: Context<SwapUsdcToUsdt>, amount: u64) -> Result<()> {
    // 0. Checks
    if ctx.accounts.global_state.paused {
        return err!(CustomErrorCode::Paused);
    }

    // 1. Transfer USDC from User to Vault
    let cpi_accounts = Transfer {
        from: ctx.accounts.user_token_account.to_account_info(),
        to: ctx.accounts.psm_vault.to_account_info(),
        authority: ctx.accounts.user.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    token::transfer(cpi_ctx, amount)?;

    // 2. Mint USDT to User (1:1 minus fee?)
    // If we want exact 1:1, usually no fee or small fee.
    // Let's assume 1:1 for simplicity.
    
    // Check decimals?
    // Assuming both are 6 decimals. If not, scaling needed.
    // Let's assume matching decimals for MVP.
    
    let seeds = &[b"global_state".as_ref(), &[ctx.accounts.global_state.bump]];
    let signer = &[&seeds[..]];

    let cpi_accounts_mint = MintTo {
        mint: ctx.accounts.usdt_mint.to_account_info(),
        to: ctx.accounts.user_usdt_account.to_account_info(),
        authority: ctx.accounts.global_state.to_account_info(),
    };
    let cpi_program_mint = ctx.accounts.token_program.to_account_info();
    let cpi_ctx_mint = CpiContext::new_with_signer(cpi_program_mint, cpi_accounts_mint, signer);
    token::mint_to(cpi_ctx_mint, amount)?;

    // Update stats
    ctx.accounts.psm_config.total_minted = ctx.accounts.psm_config.total_minted.checked_add(amount).unwrap();
    
    msg!("Swapped {} USDC for USDT", amount);
    Ok(())
}

#[derive(Accounts)]
pub struct SwapUsdtToUsdc<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        mut,
        seeds = [b"psm", token_mint.key().as_ref()],
        bump = psm_config.bump,
    )]
    pub psm_config: Account<'info, PsmConfig>,

    pub token_mint: Account<'info, Mint>,

    #[account(
        mut,
        seeds = [b"psm_vault", token_mint.key().as_ref()],
        bump,
    )]
    pub psm_vault: Account<'info, TokenAccount>,

    #[account(
        mut,
        associated_token::mint = token_mint,
        associated_token::authority = user,
    )]
    pub user_token_account: Account<'info, TokenAccount>,

    #[account(
        mut,
        seeds = [b"mint"],
        bump,
    )]
    pub usdt_mint: Account<'info, Mint>,

    #[account(
        mut,
        associated_token::mint = usdt_mint,
        associated_token::authority = user,
    )]
    pub user_usdt_account: Account<'info, TokenAccount>,
    
    #[account(
        seeds = [b"global_state"],
        bump = global_state.bump,
    )]
    pub global_state: Account<'info, GlobalState>,

    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, anchor_spl::associated_token::AssociatedToken>,
    pub system_program: Program<'info, System>,
}

pub fn handler_swap_to_usdc(ctx: Context<SwapUsdtToUsdc>, amount: u64) -> Result<()> {
    if ctx.accounts.global_state.paused {
        return err!(CustomErrorCode::Paused);
    }

    // 1. Burn USDT
    let cpi_accounts = Burn {
        mint: ctx.accounts.usdt_mint.to_account_info(),
        from: ctx.accounts.user_usdt_account.to_account_info(),
        authority: ctx.accounts.user.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    token::burn(cpi_ctx, amount)?;

    // 2. Transfer USDC from Vault
    let seeds = &[b"global_state".as_ref(), &[ctx.accounts.global_state.bump]];
    let signer = &[&seeds[..]];

    let cpi_accounts_transfer = Transfer {
        from: ctx.accounts.psm_vault.to_account_info(),
        to: ctx.accounts.user_token_account.to_account_info(),
        authority: ctx.accounts.global_state.to_account_info(),
    };
    let cpi_ctx_transfer = CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), cpi_accounts_transfer, signer);
    token::transfer(cpi_ctx_transfer, amount)?;
    
    // Update stats
    ctx.accounts.psm_config.total_minted = ctx.accounts.psm_config.total_minted.checked_sub(amount).unwrap();

    msg!("Swapped {} USDT for USDC", amount);
    Ok(())
}
use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Transfer};
use crate::state::*;
use crate::utils::get_price;

#[derive(Accounts)]
pub struct WithdrawCollateral<'info> {
    #[account(mut)]
    pub owner: Signer<'info>,

    #[account(
        mut,
        seeds = [b"position", owner.key().as_ref(), collateral_mint.key().as_ref()],
        bump = position.bump,
        has_one = collateral_mint,
        has_one = owner,
    )]
    pub position: Account<'info, Position>,

    #[account(
        seeds = [b"collateral", collateral_mint.key().as_ref()],
        bump = collateral_config.bump,
    )]
    pub collateral_config: Account<'info, CollateralConfig>,

    /// CHECK: Validated against config
    #[account(
        address = collateral_config.oracle
    )]
    pub oracle: AccountInfo<'info>,

    #[account(
        mut,
        seeds = [b"vault", collateral_mint.key().as_ref()],
        bump,
        token::mint = collateral_mint,
        token::authority = vault_authority,
    )]
    pub vault_token_account: Account<'info, TokenAccount>,

    /// CHECK: Vault authority PDA
    #[account(seeds = [b"vault_authority"], bump)]
    pub vault_authority: AccountInfo<'info>,

    pub collateral_mint: Account<'info, token::Mint>,

    #[account(
        mut,
        associated_token::mint = collateral_mint,
        associated_token::authority = owner,
    )]
    pub user_token_account: Account<'info, TokenAccount>,

    pub token_program: Program<'info, Token>,

    #[account(
        seeds = [b"global_state"],
        bump = global_state.bump,
    )]
    pub global_state: Account<'info, GlobalState>,
}

pub fn handler(ctx: Context<WithdrawCollateral>, amount: u64) -> Result<()> {
    // 0. Governance Checks
    let global_state = &ctx.accounts.global_state;
    if global_state.paused {
        return err!(CustomErrorCode::Paused);
    }
    
    let position = &mut ctx.accounts.position;
    if position.is_frozen {
        return err!(CustomErrorCode::Frozen);
    }

    // 1. Calculate New Collateral Amount
    let new_collateral_amount = position.collateral_amount.checked_sub(amount).ok_or(CustomErrorCode::InsufficientCollateral)?;

    // 2. Check Solvency if Debt > 0
    if position.debt_amount > 0 {
        let price = get_price(&ctx.accounts.oracle)?; // e.g. 150*10^6
        
        let collateral_val = (new_collateral_amount as u128)
            .checked_mul(price as u128).unwrap()
            .checked_div(10u128.pow(ctx.accounts.collateral_mint.decimals as u32)).unwrap() as u64;
            
        let mcr_percent = ctx.accounts.collateral_config.mcr;
        let required_collateral_value = (position.debt_amount as u128)
            .checked_mul(mcr_percent as u128).unwrap()
            .checked_div(100).unwrap();
            
        if (collateral_val as u128) < required_collateral_value {
            return err!(CustomErrorCode::BelowMcr);
        }
    }

    // 3. Update Position
    position.collateral_amount = new_collateral_amount;
    position.last_updated = Clock::get()?.unix_timestamp;

    // 4. Transfer Tokens
    let seeds = &[b"vault_authority".as_ref(), &[ctx.bumps.vault_authority]];
    let signer = &[&seeds[..]];

    let cpi_accounts = Transfer {
        from: ctx.accounts.vault_token_account.to_account_info(),
        to: ctx.accounts.user_token_account.to_account_info(),
        authority: ctx.accounts.vault_authority.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);
    token::transfer(cpi_ctx, amount)?;

    msg!("Withdrew {} collateral. New Balance: {}", amount, position.collateral_amount);
    Ok(())
}


